### 缓存

#### 缓存是什么

客户端在向服务端发送请求的时候，首先会对缓存进行查询，如果缓存内存在，那么就直接使用缓存内的内容

##### 缓存分类

内存缓存(from memory cache)。内存缓存具有两个特点，分别是快速读取和时效性： 

+ 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 

+ 时效性：一旦该进程关闭，则该进程的内存则会清空。 

硬盘缓存(from disk cache)：

+ 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。

##### 浏览器中的缓存

在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中（读取非常频繁），那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件（一次读取）则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。



![](E:\Code\笔记\笔记图片\缓存使用顺序.png)

#### 强缓存

当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

##### Expires

Expires是HTTP/1.0控制网页缓存的字段。其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。

<u>expires存在一个问题：服务器的时间和浏览器的时间可能不一致。</u>

##### Cache-Control

产生原因： Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同）发生误差，那么强缓存则会直接失效.

cache-contral的可选项

- public：所有内容都将被缓存（客户端和代理服务器都可缓存）
- private：所有内容只有客户端可以缓存，Cache-Control的默认取值
- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

#### 协商缓存

协商缓存就是强制缓存失效后，浏览器在请求头中携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高

##### **Last-modified**  

Last-modified时服务器文件的最后修改时间，需要和cache-contral共同使用。浏览器发送请求，向服务器传送If-Modified-Since报头，询问Last-Modified的时间点过后资源是否被修改过，如果修改过则重新请求资源。有以下两种情况：

1.  协商缓存生效，返回304
2. 协商缓存失效，返回200和请求结果

##### **ETag**  

当浏览器第一次请求一个资源，服务器会为其生成一个ETag字段并返回给浏览器。  浏览器第二次请求该资源，会在http请求头添加If-None-Match标记，将上一次获得的ETag发回去。服务器比对该ETag对应的资源，检查是否这段时间内是否发生了变化。返回的状态码和Last-Modified一样。   ETag在nginx里面默认开启，请求的文件发生了改动，会在响应头里面生成新的ETag值。  



##### **Etag与Last-modified对比**

- 某些服务器不能精准获取资源修改时间，所以根据最后修改时间判断资源是否更新有误差
- 资源修改非常频繁时（小于一秒），Last-modified不能检测到小于一秒的资源改变。
- 资源内容没修改，时间改变了，Etag可以识别出文件没有改变，让浏览器继续使用缓存。









