### 输入 URL 到页面渲染

1. [DNS解析](https://juejin.cn/post/6919755385330991112#heading-13)
2. TCP握手
3. TLS握手
4. 浏览器开始解析文件
5. 构建 DOM 树、构建 CSSOM 树、解析JS
6. 生成 Render 树
7. 调用 GPU 绘制，合成图层，将内容显示在屏幕上

#### DNS解析流程

1）搜索**浏览器的 DNS 缓存**，缓存中维护一张域名与 IP 地址的对应表；

2）若没有命中，则继续搜索**操作系统的 DNS 缓存**；

3）若仍然没有命中，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是**递归查询**）；

4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行**迭代查询**（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：

- 首先本地域名服务器向**根域名服务器**发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案
- 本地域名服务器拿到这个**顶级域名服务器**的地址后，就向其发起请求，获取**权限域名服务器**的地址
- 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址

4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来

5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来

6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来



### [ISO七层架构](https://juejin.cn/post/6844903505111547918)



**[详细解析](https://www.jianshu.com/p/c793a279f698)**



![osi七层架构](../../笔记图片\OSI七层架构.jpg)

1. 应用层： 为操作系统或网络应用程序提供访问网络服务的接口，获得数据以供客户端使用。（快递公司的收件员）
2. 表示层： 数据格式化，代码转换，数据加密。（快递公司的打包员）
3. 会话层： **连接。**负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。（快递公司的调度员）
4. 传输层： **传输。**提供端对端的接口，在通信双方节点进行数据传输。（快递公司的跟单员，跟单员负责—TCP，不负责-UDP）
5. 网络层： **调度。** 找出一条相对顺畅的通路将数据传输到目标地址。（快递公司的集散中心）
6. 数据链路层： 物理层面上互连的节点之间的通信传输。（快递公司的司机）
7. 物理层： 以二进制数据形式在物理媒体上传输数据。（公路、汽车和飞机等承载货物（数据）的交通工具）

### HTTP和HTTPS

#### HTTP协议

HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。

##### [常见请求头和响应头](https://juejin.cn/post/6844903745004765198)

##### 特点

1. 支持客户/服务器模式。

2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。

4. 无连接：无连接的含义是限制**每次连接只处理一个请求**。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

5. 无状态：HTTP协议是无状态协议。无状态是指协议**对于事务处理没有记忆能力**。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

##### [HTTP状态码](https://www.cnblogs.com/starof/p/5035119.html)

2** ： 表示请求处理成功

3**： 表示要完成请求，需要进一步操作资源。通常用于重定向

4**： 请求可能出错，妨碍了服务器的处理

5**： 表示服务器错误

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL.
- 302 - 资源（网页等）被临时转移到其它URL.
- 401 - 请求未授权
- 404 - 请求的资源（网页等）不存在
- 500 - 内部服务器错误



#### HTTPS



HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

##### 工作流程

1. Tcp三次握手
2. 客户端验证服务器数字证书
3. DH算法协商对称加密算法的密钥、hash算法的密钥
4. SSL安全加密隧道协商完成
5. 网页以加密方式传输

###### [https的加密方式](https://zhuanlan.zhihu.com/p/43789231)

#### HTTP和HTTPS区别

- Http明文传输，安全性差；Https（SSL+HTTP）加密传输，安全性好
- Https需要到CA申请证书，需要一定费用。
- HTTP三次握手建立连接之交换三个包，连接快；Https除了tcp三个包还要加上SSL传输的9和包一共12个包，连接慢。
- Http默认连接端口80；Https默认443
- Https比Http更耗费资源

### [HTTP1.0、HTTP1.1、HTTP2](https://www.cnblogs.com/xiaolincoding/p/12442435.html)

> #### 说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

> **那上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？**

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

那 HTTP/2 相比 HTTP/1.1 性能上的改进：

*1. 头部压缩*

HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。

这就是所谓的 `HPACK` 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。

*2. 二进制格式*

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧和数据帧**。

![报文区别](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/24-%E6%8A%A5%E6%96%87%E5%8C%BA%E5%88%AB.png)报文区别

这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这**增加了数据传输的效率**。

*3. 数据流*

HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

每个请求或回应的所有数据包，称为一个数据流（`Stream`）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数

客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。

![HTT/1 ~ HTTP/2](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png)HTT/1 ~ HTTP/2

*4. 多路复用*

HTTP/2 是可以在**一个连接中并发多个请求或回应，而不用按照顺序一一对应**。

移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，**降低了延迟，大幅度提高了连接的利用率**。

举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

![多路复用](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/26-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)多路复用

*5. 服务器推送*

HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。

举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送（Server Push，也叫 Cache Push）。

### **[TCP和UDP](https://zhuanlan.zhihu.com/p/24860273)**

TCP和UDP都是传输层的协议，

#### TCP

TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议.必须建立连接才可以发送消息

##### [三次握手](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15#issuecomment-510300199)

目的是和对方**建立可靠的连接，使数据包的发送和接收同步**

1. client => server 只能server判断出client具备发送能力。
2. server => client client就可以判断出server具备发送和接受能力。
3. client => server 双方均保证了自己的接收和发送能力没有问题。

##### [四次挥手](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15#issuecomment-469219581)

TCP是全双工信道，全双工就是客户端与服务端建立两条通道，1: 客户端的输出连接服务端的输入；2: 客户端的输入连接服务端的输出。

1. client => server . 告诉server我要关闭通道。（此时服务端可能还有数据包没发完）
2. server => client。 告诉client我没有数据包要发了，我们可以关闭这条通道。
3. server => client。 告诉server我要关闭另一条通道。（不能确定client会不会再发数据）
4. client => server . 告诉server我没有数据包要发了，我们可以关闭这条通道。

#### UDP

UDP(User Data Protocol，用户数据报协议),传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 

#### TCP和UDP区别

|       TCP        |       UDP        |
| :--------------: | :--------------: |
| 三次握手建立链接 |      无连接      |
|  要求系统资源多  | 要求系统资源较少 |
|  字节流模式传输  |  数据包模式传输  |
|  保证数据准确定  |    有可能丢包    |
|   保证数据顺序   |  不保证数据顺序  |
|      效率低      |      效率高      |
|      全双工      |      多对多      |



