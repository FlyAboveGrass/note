首先我们要知道两点：

1. JavaScript是**单线程**的语言
2. JavaScript在处理异步操作时，利用的是**事件循环机制。**

### **宏任务**

在事件循环event loop中，异步事件并不会放到当前任务执行队列，而是会被挂起，放入另外一个回调队列。当前的任务队列执行结束以后，JavaScript引擎回去检查回调队列中是否有等待执行的任务，若有会把第一个任务加入执行队列，然后不断的重复这个过程。

![](E:\Code\笔记\笔记图片\宏任务.png)

浏览器下触发宏任务的操作都有哪些（其他环境下会有不同）：

1. I/O 操作
2. setTimeout/setInterval
3. *requestAnimationFrame* 
4. *ajax（xhr是浏览器的api，不是v8引擎实现的）*



​	由于 JavaScript 是单线程，所以 setTimeout 的计时操作一定不是JavaScript来做的，否则会造成代码执行的阻塞。   	那么这种操作是由谁来做的？**是宿主环境**。当定时器定义， 浏览器就会进行一个计时操作，计时完成以后，将 setTimeout 的回调放入 JavaScript 事件循环的回调队列中。这样 JavaScript 就可以在接下来的执行中处理这个回调。
   **宏任务便是 JavaScript 与宿主环境产生的回调，需要宿主环境配合处理并且会被放入回调队列的任务都是宏任务。**

### **微任务**   

把执行队列从开始到结束这样的一个过程，称为一个tick，回调队列的第一个事件则会在下一个tick中被执行，第二个事件会在下下个tick中...这样依次执行。   

**（微任务队列）**作业队列则是位于当前tick的最尾部，**在当前tick中添加的微任务都不会留到下一个tick，而是在tick的尾部触发执行。**  

所以说， **同一个执行队列产生的微任务总是会在宏任务之前被执行**。

触发微任务的操作为：

1. Promise
2. MutationObserver

![](E:\Code\笔记\笔记图片\微任务.png)

### **经典面试题**

```
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1') // 1
})
promise1.then(() => {
  console.log(3); // 2
});
console.log('1', promise1); // 3


const fn = () => (new Promise((resolve, reject) => {
  console.log(2); //4
  resolve('success')
}))
fn().then(res => {
  console.log(res) // 5
})
console.log('start') // 6
```

解析：

1. 函数定义，同步任务，立刻打印
2. 异步微任务，放入微任务队列，本tick的最后执行。但是由于promise1没有resolve，所以说状态不会改变，一直不会执行.then()中的回调。
3. 语句，同步任务，立刻打印。promise1还未执行，状态仍未pending
4. 箭头函数内的promise定义，依然是定义行为，同步任务，立刻执行
5. 微任务执行，打印resolve出来的sucess。
6. 同步任务，立刻打印。