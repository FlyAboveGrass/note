> [双线程架构 | 前端那些事儿](https://jonny-wei.github.io/blog/mobile/mini/framework.html)

# 双线程主要是为了处理小程序的安全管控

目前来说，**页面渲染的方式主要有三种**：

1. Web 渲染。
2. Native 原生渲染。
3. Web 与 Native 两者掺杂，也即我们常说的 Hybrid 渲染。


我们结合之前对小程序的期望来看：

- 开发门槛：Web 门槛低，不过 Native 也有像 RN 这样的框架支持
- 体验：Native 体验比 Web 不要好太多，Hybrid 在一定程度上比 Web 接近原生体验
- 版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布
- 管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险


**为什么不能使用原生开发**
纯客户端原生技术来编写小程序 ，那小程序代码需要与微信代码一起编包，跟随微信发版本，这种方式跟开发节奏必然都是不对的。 所以方向应该是需要像 Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。

**为什么不能使用 Web 开发**
但是如果用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题。 这是因为在 Web 技术中，UI 渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占 UI 渲染的资源。


**小程序选择了 Hybrid 的渲染方式**

小程序技术选型 - 选择类似于微信 JSSDK 这样的 Hybrid 技术，即界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。同时，每个小程序页面都是用不同的WebView去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个 WebView 的任务过于繁重。

小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：

- 扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力
- 体验更好，同时也减轻 WebView 的渲染工作
- 绕过 setData、数据通信和重渲染流程，使渲染性能更好



现在，我们还剩下一个很重要的问题：管控性和安全性。于是，双线程的设计被提出来了。

# 什么是双线程模型

和web页面UI渲染和脚本执行在一个单线程不同，小程序采用了双线程架构设计，将试图渲染与业务逻辑分别运行在两个不同的线程中

![image-20210402145125405](小程序双线程模型.png)

![image-20210402145752591](小程序双线程原理.png)

由于渲染层与逻辑层分开，一个小程序有多个界面，所以渲染层对应存在多个 `webview`。这两个线程之间由 `Native` 层进行统一处理。无论是线程之间的通讯、数据的传递、网络请求都由 Native 层做转发。

- 逻辑层：创建一个单独的线程去执行 JavaScript，逻辑层的代码全部载入到一个 webview 里面，称为 appservice， 整个小程序只有一个，而且整个生命周期常驻内存。
- 渲染层：视图层（wxml、wxss） 都是由单独的 webview 来承载， 称为 appView。
- 通信：在渲染层的请求并不会直接到了逻辑层，而是会先到了系统层。在系统层先进行操作处理一部分功能再将数据传递给逻辑层，逻辑层也一样。所以不能频繁进行setdata请求绑定交互。



## 逻辑层

可以把 AppService 理解为一个简单的页面，主要功能是负责逻辑处理部分的执行，底层提供一个 WAService.js 的文件来提供各种api接口

整个AppService 就是载入很多的 js 文件，并且将整个包都缓存在用户本地，使得可以有需要的更新。


JS 逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API，无法操作页面元素，能达到管控的目的，但也限制了开发者的权限：
- 不允许开发者把页面跳转到其他在线网页
- 不允许开发者直接访问 DOM
- 不允许开发者随意使用 window 上的某些未知的可能有危险的 API

这样的逻辑层与 UI 层的隔离，加上小程序的审核和举报机制，使得微信加强对小程序的管控

## 视图层

接近于web 的视图层， 但是某些标签被小程序提供的组件代替。

**和逻辑层通信：**

1. 小程序逻辑层调用宿主环境的 setData 方法。
2. 逻辑层执行 JSON.stringify 将待传输数据转换成字符串拼接到特定的JS脚本，并通过evaluateJava 执行脚本将数据传输到渲染层。
3. 渲染层接收到后， WebView JS 线程会对脚本进行编译，将js对象再次转化成真实的Dom结构，交由渲染层线程渲染。得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。
4. WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将最新变化的内容反映到真实的DOM树中，更新UI。同时，将新的节点树替换旧节点树，用于下一次重渲染。



## 为什么要做多个`webview`

为了更加接近原生应用APP的用户体验。

多个 `webview` 可以理解为多页面应用，有别于单页面应用 `SPA`，`SPA` 渲染页面是通过路由识别随后动态将页面挂载到 `root` 节点中去，如果单页面应用打开一个新的页面，需要先卸载掉当前页面结构，并且重新渲染。

很显然原生APP并不是这个样子，比较明显的特征为从页面右侧向左划入一个新的页面，并且我们可以同时看到两个页面。多页面应用就很好达到这个效果，新页面直接滑动出来并且覆盖在旧页面上即可，这也是小程序现在所做的形式。这样的用户体验是非常好的。


## 延时

小程序是基于双线程模型，那就意味着**任何数据传递都是线程间的通信**，也就是都会有一定的延时。这也是大部分小程序提供的接口(API)都是异步的原因

# 为什么使用双线程


1. 毕竟不是真正的原生，在交互体验上和原生有差距
2. **web页面开发渲染线程和脚本线程是互斥的**，长时间的脚本运行可能会导致页面失去响应或者白屏
3. web 页面自由度很高，需要花费很大的人力去检查页面是否存在违规操作。


# 双线程模型的优缺点

## 优点

- 安全管控： 将逻辑层和渲染层隔离开，用户无法直接操作 `DOM`，提供了相对封闭和安全的运行环境。
- 比较好的体验： 强制使用了MVVM框架的数据驱动，即让视图状态和视图绑定在一起，同时也使用了虚拟dom优化体验
- JS 执行不会阻塞或干扰 `webView` 渲染，但是大部分情况下视觉都要依赖 JS 中处理的数据，JS 如果被阻塞（阻塞原因有逻辑重或请求慢等）了就不会通知视图去更新（即执行`setData`），所以这条优点其实意义不是很大！所以小程序官方搞出了 [初始渲染缓存 (opens new window)](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fview%2Finitial-rendering-cache.html)，会缓存初始data（不包含setData）的渲染结果。
- 所有的页面和组件的逻辑（js）都在一个线程（`AppService`）里，使用同一个上下文环境，比较好做状态共享或跨页面通讯。

## 缺点

- 每一次数据传递都要进行一次线程之间的通信，业务逻辑跟渲染层天然隔离，造成通信开销大、延迟高等问题，通信越频繁、数据量越大，则性能瓶颈越严重。
- 每个页面都创建一个`WebView`线程处理，有更多的内存、时间开销。
- 渲染层和逻辑层状态要维护两份，进一步加重内存、时间开销，并且没有办法完全保证两份数据状态实时保持一致，例如仅使用 `this.data` 更新数据而不是通过`setData`时，那么实际渲染的值与逻辑层的值就不一致，某些场景下会造成非预期的问题。



## 小结

总体上从开发者的角度来看，小程序的双线程模型架构并不是一个很好的架构，逻辑层与渲染层隔离，带来的问题远远比它解决的问题更多。

除了状态共享和跨页面通信外，几乎对开发者来说没啥吸引力，但是依旧很鸡肋：

1. 一个应用里面的多个页面，你认为是共享的状态多，还是独立的状态多？
2. 用户在操作页面时，更关心跨页面通信效率，还是更关心当前页面的渲染效率（页面里的内容是否顺滑）？

我们当然更关心性能，但是从微信的角度来说，他们想既能享受 `web` 生态的好处的同时也能限制 `web` 的开放性，增强自己对平台内容的**管控程度**，从禁用 `eval` 和 `new Function()` 上就能看出一二。

当然微信也知道架构所带来的性能问题，所以发明了 `WXS` ，让一部分 `js` 代码能在渲染层跑，**部分**解决通信消耗和延迟的问题，只能满足很小一部分场景，依旧很鸡肋。


综上所述，优化`setData`是一个小程序应用无法忽略的关键一步，它占了小程序性能体验的大头，理应贯穿整个小程序开发周期。

# 性能问题

## setData传递大量数据

数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程
## 频繁执行setData

频繁的执行 setData 会让 WebView JS 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。导致的结果是：

- 页面渲染结果有一定的延时。
- 用户触发页面事件时，因 WebView JS 线程忙碌，用户事件未能及时的传输到逻辑层而导致反馈延迟。


最典型的例子就是在setData中进行复杂的动画的编写，如果要让人眼觉得动画是流畅的，那么必须每秒钟更新24 帧。双线程模型使得setData是不稳定的、有延迟的，那么就会造成有时候一下渲染几次，有时候很久不渲染。 所以**对于复杂动画，我们可以使用 wxs 去进行性能优化。**

## 过多的页面节点

- 页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。
- 每次执行 setData 更新视图，WebView JS 线程都要遍历节点树计算新旧节点数差异部分。当页面节点数量越多，计算的时间开销越大，减少节点树节点数量可以有效降低重渲染的时间开销。


## 如何优化？

### 自定义组件

基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。

当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。

> 但是不是使用自定义组件越多会越好，页面每新增一个自定义组件， Exparser 需要多管理一个组件实例，内存消耗会更大

### wxs

对于与数据没有直接关系的逻辑，我们可以使用wxs 进行代替。
