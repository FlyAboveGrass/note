## 什么是双线程模型

和web页面UI渲染和脚本执行在一个单线程不同，小程序采用了双线程架构设计，将试图渲染与业务逻辑分别运行在两个不同的线程中

![image-20210402145125405](小程序双线程模型.png)

## 为什么使用双线程



1. 毕竟不是真正的原生，在交互体验上和原生有差距
2. **web页面开发渲染线程和脚本线程是互斥的**，长时间的脚本运行可能会导致页面失去响应或者白屏
3. web 页面自由度很高，需要花费很大的人力去检查页面是否存在违规操作。



#### 双线程解决什么

体验： 强制使用了MVVM框架的数据驱动，即让视图状态和视图绑定在一起，同时也使用了虚拟dom优化体验

管控：阻止开发者使用浏览器的开发性接口，通过提供一个沙盒环境来运行开发者的js代码，只能使用微信提供开放的方法来获取元素的一些信息。





## 双线程原理



**小程序是基于 web 规范封装的一套 Hybrid 框架。**



小程序的逻辑层和渲染层是用多个webview 实现的。

逻辑层的代码全部载入到一个 webview 里面，称为 appservice， 整个小程序只有一个，而且整个生命周期常驻内存。

视图层（wxml、wxss） 都是由单独的 webview 来承载， 称为 appView。

appService和 appView 由Native来做中转媒介。



![image-20210402145752591](小程序双线程原理.png)







在渲染层的请求并不会直接到了逻辑层，而是会先到了系统层。在系统层先进行操作处理一部分功能再将数据传递给逻辑层，逻辑层也一样。所以不能频繁进行setdata请求绑定交互。





### 逻辑层

可以把AppService理解为一个简单的页面，主要功能是负责逻辑处理部分的执行，底层提供一个WAService.js的文件来提供各种api接口



整个AppService 就是载入很多的 js 文件， 并且将整个包都缓存在用户本地， 使得可以有需要的更新。



### 视图层

接近于web 的视图层， 但是某些标签被小程序提供的组件代替。



**和逻辑层通信：**

1. 小程序逻辑层调用宿主环境的 setData 方法。
2. 逻辑层执行 JSON.stringify 将待传输数据转换成字符串拼接到特定的JS脚本，并通过evaluateJava 执行脚本将数据传输到渲染层。
3. 渲染层接收到后， WebView JS 线程会对脚本进行编译，将js对象再次转化成真实的Dom结构，交由渲染层线程渲染。得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。
4. WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将最新变化的内容反映到真实的DOM树中，更新UI。同时，将新的节点树替换旧节点树，用于下一次重渲染。





### 延时

小程序是基于双线程模型，那就意味着**任何数据传递都是线程间的通信**，也就是都会有一定的延时。这也是大部分小程序提供的接口(API)都是异步的原因



双线程模型使







## 性能问题



### setData传递大量数据

数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程





### 频繁执行setData

频繁的执行 setData 会让 WebView JS 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。导致的结果是：

- 页面渲染结果有一定的延时。
- 用户触发页面事件时，因 WebView JS 线程忙碌，用户事件未能及时的传输到逻辑层而导致反馈延迟。



最典型的例子就是在setData中进行复杂的动画的编写，如果要让人眼觉得动画是流畅的，那么必须每秒钟更新24 帧。双线程模型使得setData是不稳定的、有延迟的，那么就会造成有时候一下渲染几次，有时候很久不渲染。 所以**对于复杂动画，我们可以使用 wxs 去进行性能优化。**



### 过多的页面节点

- 页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。
- 每次执行 setData 更新视图，WebView JS 线程都要遍历节点树计算新旧节点数差异部分。当页面节点数量越多，计算的时间开销越大，减少节点树节点数量可以有效降低重渲染的时间开销。



### 优化： 自定义组件

基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。

当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。



### 优化： wxs

对于与数据没有直接关系的逻辑，我们可以使用wxs 进行代替。



> 但是不是使用自定义组件越多会越好，页面每新增一个自定义组件， Exparser 需要多管理一个组件实例，内存消耗会更大



