> 参考链接:
>
> [微前端的那些事儿](https://microfrontends.cn/)
>
> [可能是你见过最完善的微前端解决方案](https://zhuanlan.zhihu.com/p/78362028)
>

  [基于 qiankun 的微前端最佳实践](https://github.com/a1029563229/blogs/blob/master/BestPractices/qiankun/Start.md)





# 概念



![image-20210506142751472](微前端特性.png)

微前端类似于服务端的微服务，将 web 应用由单一的单体应用转化成 **多个小型的前端应用聚合为一的应用**。各个前端应用之间**独立开发、独立运行、独立部署**

> 这里的前端应用指的是前后端分离的单页面应用

# 为什么需要

- 技术栈无关
- 独立开发，独立部署
- 独立运行，子应用状态隔离，运行时状态不共享


## 解决巨石应用

随着业务更进一步的增长，接入的业务模块越来越多，不仅我们以导航维度扩充的子应用增多，页面上也会有归属于多个业务域的区块。如果没有很好的处理和子系统的拆分，那么我们的应用就会变成巨石应用。

微前端 **分而治之**的策略可以很好的解决巨石应用的问题。


## 前端遗留系统迁移

**解决遗留系统**，这是采用微前端方案的最重要的原因

## 后端解耦，前端聚合

大的商业公司会提供一系列的应用，但是用户眼里它们就是一个公司，只应该有一个产品，他们不想安装那么多应用。聚合是一个技术趋势，微前端就是前端的聚合。

![[Pasted image 20250113112908.png]]

## 兼容遗留系统

需要使用新的技术、新的架构，来容纳、兼容这些旧的应用


## 兼顾 MPA 和 SPA 的优势


MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。

SPA 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。缺点则在于各应用技术栈之间是强耦合的。


# 实施微前端的六种方式



## 基础铺垫：应用分发路由 -> 路由分发应用



后端：函数调用 -> 远程调用

前端：组件调用 -> 应用调用



微前端是将 **应用内的组件调用**变成了更细粒度的**应用间组件调用**。

原先是将路由分发到应用的组件执行，现在是根据路由来找到对应的应用，在由应用分发到对应的组件上。



### 微前端选型



![](choice-your-microservices.png)



### 微前端实现方式对比

![image-20210506113415722](微前端实现方式对比.png)





## [路由分发式微前端](https://microfrontends.cn/#路由分发式微前端)



**路由分发式微前端**，即通过路由将不同的业务**分发到不同的、独立前端应用**上。其通常可以通过 HTTP 服务器的反向代理来实现，又或者是应用框架自带的路由来解决。


当前来说，这种方式是采用最多、最易采用的“微前端”方案。这种方案更像是将多个前端应用拼在一起，使他们看起来像是一个完整的整体。但是它们并不是，每次用户从 A 应用到 B 应用的时候，往往需要刷新一下页面。


**适用场景**

- 不同技术栈之间差异比较大，难以兼容、迁移、改造
- 项目不想花费大量的时间在这个系统的改造上
- 现有的系统在未来将会被取代
- 系统功能已经很完善，基本不会有新需求





## [使用 iFrame 创建容器](https://microfrontends.cn/#使用-iframe-创建容器)



iframe 可以创建一个全新的独立的宿主环境，这意味着我们的前端应用之间可以相互独立运行。但是它有两个使用前提：

1. 网站不需要 seo 支持
2. 有相应的**应用管理机制**



## [自制框架兼容应用](https://microfrontends.cn/#自制框架兼容应用)



前端框架都离不开 dom，那么我们自制微前端框架只需要：

1. 在页面合适的地方引入或者创建 DOM （easy）
2. 用户操作时，加载对应的应用（触发应用的启动），并能卸载应用。（不同框架不同卸载，很难统一）







## [组合式集成：将应用微件化](https://microfrontends.cn/#组合式集成将应用微件化)



**组合式集成**，即通过**软件工程**的方式在构建前、构建时、构建后等步骤中，对应用进行一步的拆分，并重新组合。



定义上不算事微前端，但是满足“**独立运行、独立开发、独立部署**”，加上异步加载业务组件和应用，看起来就是一个微前端应用。









## [纯 Web Components 技术构建](https://microfrontends.cn/#纯-web-components-技术构建)

Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 Web 应用中使用它们。



**组成**

- Custom elements，创建自定义的元素 。
- Shadow DOM，通常是将 Shadow DOM 附加到主文档 DOM 中，并可以控制其关联的功能。而这个 Shadow DOM 则是不能直接用其它主文档 DOM 来控制的。
- HTML templates，即 `<template>` 和 `<slot>` 元素，用于编写不在页面中显示的标记模板。
- HTML Imports，用于引入自定义组件。



## 结合 Web Components 构建



### [在 Web Components 中集成现有框架](https://microfrontends.cn/#在-web-components-中集成现有框架)



### [集成在现有框架中的 Web Components](https://microfrontends.cn/#集成在现有框架中的-web-components)





## [复合型](https://microfrontends.cn/#复合型)





# 如何解构单体前端应用



## 前端微服化

- #### 独立开发
- #### 独立部署
- #### 技术无关
- #### 不影响用户体验





## 微前端的设计理念

### [中心化路由](https://microfrontends.cn/#设计理念一中心化路由)

### [标识化应用](https://microfrontends.cn/#设计理念二标识化应用)

### [生命周期](https://microfrontends.cn/#设计理念三生命周期)

- load，决定加载哪个应用，并绑定生命周期
- bootstrap，获取静态资源
- mount，安装应用，如创建 DOM 节点
- unload，删除应用的生命周期
- unmount，卸载应用，如删除 DOM 节点

### [独立部署与配置自动化](https://microfrontends.cn/#设计理念四独立部署与配置自动化)





## 实战微前端架构设计



### [独立部署与配置自动化](https://microfrontends.cn/#独立部署与配置自动化)



### [应用间路由——事件](https://microfrontends.cn/#应用间路由事件)









# 微前端架构实践中遇到的问题



## 路由系统和 Future State



### Future State 问题

子应用都是 lazy load 的，当浏览器重新刷新时，主框架的资源会被重新加载，同时异步 load 子应用的静态资源，由于此时主应用的路由系统已经激活，但子应用的资源可能还没有完全加载完毕，从而导致路由注册表里发现没有能匹配子应用 `/subApp/123/detail` 的规则



### 解决方案

主框架配置子应用的路由为 `subApp: { url: '/subApp/**', entry: './subApp.js' }`，则当浏览器的地址为 `/subApp/abc` 时，框架需要先加载 entry 资源，待 entry 资源加载完毕，确保子应用的路由系统注册进主框架之后后，再去由子应用的路由系统接管 url change 事件。同时在子应用路由切出时，主框架需要触发相应的 destroy 事件，子应用在监听到该事件时，调用自己的卸载方法卸载应用





## App Entry



### 构建时组合 VS 运行时组合

|      | 构建时组合                                                   | 运行时组合                                   |
| ---- | ------------------------------------------------------------ | -------------------------------------------- |
| 方案 | 自应用通过 package registry 的方式，与主应用一起打包发布     | 自应用自己构建打包，主应用动态加载自应用资源 |
| 优点 | 主应用和自应用之间可以进行打包优化                           | 主应用和子应用之间完全解耦                   |
| 缺点 | 子应用和主应用工具链耦合，<br />子应用每次发布依赖主应用重新打包发布 | 会多出来一些运行时复杂度和 overhead          |

### JS entry 和 HTML entry



![v2-dde4d233b0b55039ad309dfb2db0a5d4_1440w](微前端入口js和html对比.jpg)





## 模块导入



## 应用隔离



### 样式隔离

**dynamic sheet**

解决方案其实很简单，我们只需要在应用切出/卸载后，同时卸载掉其样式表即可，原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到 插入、卸载 样式的目的。这样即能保证，在一个时间点里，只有一个应用的样式表是生效的。



### js 隔离



在应用的 bootstrap 及 mount 两个生命周期开始之前分别给全局状态打下快照，然后当应用切出/卸载时，将状态回滚至 bootstrap 开始之前的阶段，确保应用对全局状态的污染全部清零。而当应用二次进入时则再恢复至 mount 前的状态的，从而确保应用在 remount 时拥有跟第一次 mount 时一致的全局上下文。
