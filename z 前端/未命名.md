
# Vue



# 行内元素和块元素的区别是什么

行内元素和块元素是HTML中的两种基本元素类型，它们在网页布局和样式上有不同的表现和用途。

行内元素（Inline Elements）

- 定义：行内元素不会在页面上独占一行，它们只占据其内容所需的宽度。
- 特点：
- 不会在其前后自动换行。
- 可以与其他行内元素或文本内容在同一行内。
- 常用于格式化文本，如 a、span、strong、em、img 等。
- 行内元素的宽度和高度通常由内容决定，不能通过CSS设置宽高（width 和 height）。

块元素（Block Elements）

- 定义：块元素通常在页面上独占一行，前后有换行。
- 特点：
- 默认情况下，块元素会在其前后产生换行。
- 可以包含其他块元素和行内元素。
- 常用于布局结构，如 div, p, h
- 可以通过CSS设置宽度和高度（width 和 height）。

差异总结：
- 布局行为：行内元素不会打断文本流，而块元素会在其前后产生换行。
- 内容：行内元素通常用于小的内容片段或文本格式化，而块元素用于大的内容块或布局结构。
- CSS控制：块元素可以通过CSS更灵活地控制尺寸和布局，而行内元素的尺寸通常由内容决定。


# 垃圾回收机制

[[垃圾回收机制]]


# 前端安全

[[前端安全]]


# 性能优化

- 代码拆分
- 懒加载
- 预加载
- 代码压缩
- 图片优化
- 缓存策略
- 服务端渲染
- 内容分发网络 (CDN)
- Tree Shaking
- 资源合并
- 资源内联
- 关键渲染路径优化
- 使用 Web Workers
- 减少重排和重绘

**代码层面**
- 虚拟列表
- 骨架屏
- 代码分割
- 懒加载组件
- 防抖和节流
- 减少虚拟 dom 重新渲染（memo、固定 key、 ref 存储非渲染内容）


# 数组去重

**Set**

性能最好的方式。时间复杂度为 O（n），空间复杂度为 O（n）

```
function removeDuplicates(arr) {
    return [...new Set(arr)];
}
```


哈希表

```
function removeDuplicates(arr) {
    const seen = {};
    return arr.filter(item => {
        if (seen[item]) {
            return false;
        } else {
            seen[item] = true;
            return true;
        }
    });
}

```


双重遍历

```
function removeDuplicates(arr) {
    arr.sort();
    return arr.filter((item, index) => arr.indexOf(item) === index);
}


```

```
function removeDuplicates(arr) {
  const newArr = []
  arr.forEach(item => {
    if (!newArr.includes(item)) {
      newArr.push(item)
    }
  })
  return newArr
}
```



![[Pasted image 20250228172945.png]]


# 节流防抖

防抖
setTimeout 计算重置的时间

```
function debounce(callback, timeout) {
    let timer = null;

    return function (...args) {
        const context = this;
        if (timer) {
            clearTimeout(timer);
        }
        
        timer = setTimeout(() => {
            callback.apply(context, args);
        }, timeout);
    };
}

```


节流
```
function throttle(fn, delay) {
    var previous = 0;
    // 使用闭包返回一个函数并且用到闭包函数外面的变量previous
    return function() {
        var _this = this;
        var args = arguments;
        var now = new Date();
        if(now - previous > delay) {
            fn.apply(_this, args);
            previous = now;
        }
    }
}
```


# 正则表达式

邮箱
`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`

手机号
`/^1[3-9]\d{9}$/`

日期 YYYY-MM-DD
`^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$`


# 原型链

[[你不知道的js#Prototype]]

### 1. 什么是原型链？

**答案：**  
原型链是 JavaScript 中实现继承的机制。每个对象都有一个内部属性 `[[Prototype]]`（可以通过 `__proto__` 访问），指向其原型对象。当访问一个对象的属性或方法时，如果对象本身没有该属性或方法，JavaScript 会沿着原型链向上查找，直到找到该属性或方法或到达==原型链的顶端（`null`）==。

### 2. 如何创建一个没有原型的对象？

**答案：**  
可以使用 `Object.create(null)` 创建一个没有原型的对象。这个对象的 `__proto__` 属性为 `null`。

### 3. 如何实现继承？

- **组合继承**（结合原型链和构造函数继承）：

```
function Parent(name) {
  this.name = name;
}
// 在 Parent 上增加可调用的函数，给子类用
Parent.prototype.sayHello = function() {
  console.log('Hello from ' + this.name);
};

function Child(name) {
  // 可以执行自己逻辑的同时，调用父类的构造函数
  Parent.call(this, name);
}
// 让实例可以通过原型链找到 Parent 上面的方法
Child.prototype = new Parent();

const child = new Child('Child');
child.sayHello(); // Hello from Child
```

- 组合寄生继承

**纯净的原型继承**
**修复 constructor**
```
function Person(name, age) {
	this.name = name,
	this.age = age
}
Person.prototype.setAge = function () {
	console.log("111")
}

function Student(name, age, price) {
	Person.call(this, name, age)
	this.price = price
	this.setScore = function () {}
}

// 核心代码，Student 可以访问到 Person 的方法和属性
// 保证了 Student 的实例无法更改 Person 原型链
Student.prototype = Object.create(Person.prototype)

// 核心代码。修复 `constructor`，不修复，`Student` 的实例的 `constructor` 属性会错误地指向 `Person`，而不是 `Student`。
// instanceof 无法正确判断 Student 是否是 Person 的子实例
Student.prototype.constructor = Student


```

### 4. `new` 关键字做了什么？

**答案：**  
`new` 关键字用于创建一个用户定义的对象类型的实例。它做了以下几件事：

1. 创建一个新对象。
2. 将新对象的 `__proto__` 指向构造函数的 `prototype`。
3. 将构造函数的作用域赋给新对象（即 `this` 指向新对象）。
4. 执行构造函数中的代码。
5. 如果构造函数没有显式返回一个对象，则返回新创建的对象。

### 5. `instanceof` 是如何工作的？

**答案：**  
`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在对象的原型链中。它沿着对象的原型链向上查找，直到找到匹配的 `prototype` 或到达原型链的顶端（`null`）。

instanceof 的简单实现
```
function myInstanceOf(obj, constructor) {
  // 获取对象的原型
  let proto = obj.__proto__

  // 沿着原型链向上查找
  while (proto !== null) {
    // 如果找到匹配的 prototype，返回 true
    if (proto === constructor.prototype) {
      return true;
    }
    // 继续向上查找
    proto = proto.__proto__
  }

  // 如果原型链顶端仍未找到，返回 false
  return false;
}
```


### 6. `Object.create` 和 `new` 的区别是什么？

**答案：**

- `Object.create(proto)` 创建一个新对象，并将新对象的 `__proto__` 设置为 `proto`。
- `new Constructor()` 创建一个新对象，并将新对象的 `__proto__` 设置为 `Constructor.prototype`，然后调用构造函数。

```
const proto = { name: 'Proto' };
const obj1 = Object.create(proto);
console.log(obj1.name); // Proto

function Constructor() {
  this.name = 'Constructor';
}
const obj2 = new Constructor();
console.log(obj2.name); // Constructor

```

### 7. 如何判断一个对象是否拥有某个属性（而不是从原型链上继承的）？

**答案：**  
可以使用 `Object.prototype.hasOwnProperty` 方法来判断一个对象是否拥有某个自有属性。

```
const obj = { name: 'Alice' };
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.hasOwnProperty('toString')); // false
```


# 事件循环

[[宏任务和微任务]]

## vue 中的 dom 更新同步 or 异步？

异步的！
为什么是异步的？
- **性能优化**：如果每次数据变化都立即更新 DOM，会导致频繁的 DOM 操作，影响性能
- **批量更新**：通过异步队列，Vue 可以将多次数据变化合并为一次 DOM 更新，减少不必要的渲染。

## vue 中的 nextTick 原理是什么

#### 1. Vue 的异步更新机制

当 Vue 中的数据发生变化时，Vue 不会立即更新 DOM，而是将需要更新的组件标记为“脏”（dirty），并将这些组件的更新操作推入一个队列中。这个队列会在当前事件循环结束后被清空，统一执行 DOM 更新。

#### 2. `nextTick` 的执行时机

`nextTick` 的回调函数会被推入同一个队列中。由于 Vue 的异步更新机制确保了 DOM 更新操作先于 `nextTick` 的回调执行，因此 `nextTick` 的回调函数会在 DOM 更新完成后执行。

#### 3. 为什么 `nextTick` 能确保 DOM 更新完成？

- Vue 的异步更新队列是一个任务队列，DOM 更新操作和 `nextTick` 的回调函数都会被推入这个队列。
- Vue 会先执行所有的 DOM 更新操作，然后再执行 `nextTick` 的回调函数。
- 因此，`nextTick` 的回调函数执行时，DOM 已经更新完成。

伪代码实现

```
const queue = []; // 异步更新队列
let pending = false; // 标记是否已经将任务推入队列

// Vue 的异步更新机制
function queueWatcher(watcher) {
  queue.push(watcher); // 将需要更新的组件推入队列
  if (!pending) {
    pending = true;
    scheduleFlush(); // 将 flushQueue 推入任务队列
  }
}

// 清空队列，执行 DOM 更新
function flushQueue() {
  pending = false;
  const copies = queue.slice(0); // 复制队列
  queue.length = 0; // 清空队列
  for (let i = 0; i < copies.length; i++) {
    copies[i].run(); // 执行 DOM 更新
  }
}

// nextTick 的实现
const callbacks = []; // 存储 nextTick 的回调函数
function nextTick(callback) {
  callbacks.push(callback); // 将回调函数推入队列
  if (!pending) {
    pending = true;
    scheduleFlush(); // 将 flushCallbacks 推入任务队列
  }
}

// 执行 nextTick 的回调函数
function flushCallbacks() {
  const copies = callbacks.slice(0); // 复制回调队列
  callbacks.length = 0; // 清空队列
  for (let i = 0; i < copies.length; i++) {
    copies[i](); // 依次执行回调
  }
}

// 将任务推入微任务或宏任务队列
function scheduleFlush() {
  if (typeof Promise !== 'undefined') {
    Promise.resolve().then(flushQueue).then(flushCallbacks);
  } else if (typeof MutationObserver !== 'undefined') {
    const observer = new MutationObserver(flushQueue);
    const textNode = document.createTextNode('1');
    observer.observe(textNode, { characterData: true });
    textNode.textContent = '2';
  } else {
    setTimeout(flushQueue, 0);
    setTimeout(flushCallbacks, 0);
  }
}
```



# 浏览器缓存

[[浏览器#缓存]]