## [编程范式](https://www.cnblogs.com/sirkevin/p/8283110.html)

​目前主流的编程范式有三种： 命令式编程、 声明式编程、 函数式编程

​		

### 命令式编程

​关注计算机执行的步骤， **一步一步告诉计算机先做什么再做什么**。 
​计算机硬件的工作方式基本都是命令式的， 编程语言也基本是基于命令式的。
​比需要在数组中筛选大于 5 的数字，如果是就将它添加到结果数组。

1. 第一步： 创建结果数组
2. 第二部： 遍历要筛选数组
3. 第三步： 判断是不是大于5， 如果是就将它加入结果集

```
let result = []
for (item in arr ){
	if(item > 5) {
		result.push(item)
	}
}
```



### 声明式编程

​声明式编程是以数据结构的形式来表达程序执行的逻辑。它的主要思想是**告诉计算机应该做什么，但不指定具体要怎么做**。

​它描述目标的性质，让计算机明白目标，而非具体过程。声明式编程不用告诉计算机问题领域，从而避免随之而来的副作用。

​它特点是 
- 它不需要创建变量用来存储数据； 
- 它不包含循环控制的代码如 for， while。

例如 sql 查询（html 和 css 也是声明式编程）

```
SELECT * FROM collection WHERE num > 5
```





### 函数式编程

​函数式编程和声明式编程是有所关联的，因为他们思想是一致的：即**只关注做什么而不是怎么做**。但函数式编程不仅仅局限于声明式编程。

​函数式编程最重要的特点是“**函数第一位**”，即函数可以出现在任何地方，比如你可以把函数作为参数传递给另一个函数，不仅如此你还可以将函数作为返回值。


具体例子可以参考 **[ramda](https://ramda.cn/docs/)**



### 面向对象编程

​并不是使用类才是面向对象编程， 只要**专注于状态改变和密封抽象**，就是面向对象编程。

​它分隔构成抽象的结构和行为的元素，描述对象的基本特征， 让我们能够专注于部分的功能， 让代码具有可扩充性和开放性。

## [函数式编程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)

### 特点

- 与命令式编程和声明式编程并列的编程范式。
- 函数是`第一等公民`, 这是最主要的特征
- 只用表达式，不用语句。强调将计算过程分解成可复用的函数，典型例子就是`map`方法和`reduce`方法组合而成 [MapReduce 算法](https://zh.wikipedia.org/wiki/MapReduce)。
- 纯函数。只有[纯的](https://zh.wikipedia.org/wiki/纯函数)、没有[副作用](https://zh.wikipedia.org/wiki/函数副作用)的函数，才是合格的函数。
    - 不修改输入数据状态。
    - 输入数据相同，输出必定相同。纯函数不是编程语言里的函数，而是数学意义上的函数映射关系。比如 y=sin(x) 中 x 和 y 值的映射关系。

### 优势

- 代码简洁，开发快速
- 接近自然语言，易于理解。
- 方便的代码管理。函数是独立单元，没有副作用。
- 易于“并发编程”。不改变状态，不用担心不同的线程修改同一数据会导致脏数据。
- 代码热升级。函数式编程没有副作用，运行状态可以直接升级代码，结果会直接反应。


### 相关特性

#### 函数是一等公民

函数是一等公民`First-Class Functions`，这是函数式编程得以实现的前提，因为我们基本的操作都是在操作函数。这个特性意味着函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。

#### 声明式编程

声明式编程`Declarative Programming`，函数式编程大多时候都是在声明我需要做什么，而非怎么去做，这种编程风格称为 声明式编程，这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。`SQL`语句就是声明式的，你无需关心`Select`语句是如何实现的，不同的数据库会去实现它自己的方法并且优化。`React`也是声明式的，你只要描述你的`UI`，接下来状态变化后`UI`如何更新，是`React`在运行时帮你处理的，而不是靠你自己去渲染和优化`diff`算法。

#### 无状态和数据不可变

无状态和数据不可变（`Statelessness and Immutable data`），是函数式编程的核心概念，为了实现这个目标，函数式编程提出函数应该具备的特性，没有副作用和纯函数。

-   数据不可变： 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。
-   无状态： 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。

#### 没有副作用

没有副作用 `No Side Effects`，是指在完成函数主要功能之外完成的其他副要功能，在我们函数中最主要的功能当然是根据输入返回结果，而在函数中我们最常见的副作用就是随意操纵外部变量。由于 `Js` 中对象传递的是引用地址，哪怕我们用 `const` 关键词声明对象，它依旧是可以变的。

保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重，最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生`Bug`。传递引用一时爽，代码重构火葬场。

#### 纯函数

纯函数`pure functions`，纯函数算是在没有副作用的要求上再进一步了。在`Redux`的三大原则中，我们看到它要求所有的修改必须使用纯函数，纯函数才是真正意义上的函数，它意味着相同的输入，永远会得到相同的输出，其实纯函数的概念很简单就是两点：

-   不依赖外部状态(无状态)：函数的的运行结果不依赖全局变量，`this`指针、`IO`操作等。
-   没有副作用(数据不变)：不修改全局变量，不修改入参。

### 流水线的构建

如果说函数式编程中有两种操作是必不可少的那无疑就是柯里化`Currying`和函数组合`Compose`，柯里化其实就是流水线上的加工站，函数组合就是我们的流水线，它由多个加工站组成。

#### 函数的合成和柯里化

##### 合成(compose)

​如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做"函数的合成"（compose）。

![image-20210408143528101](函数式编程函数合成.png)


##### 柯里化(curry)

​"柯里化"，就是把一个多参数的函数，转化为单参数函数。

```
// 柯里化之前
function add(x, y) {
  return x + y;
}

add(1, 2) // 3

// 柯里化之后
function addX(y) {
  return function (x) {
    return x + y;
  };
}

addX(2)(1) // 3
```



### 函子

​函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。
函子本身具有对外接口（`map`方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。

​函子首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。**比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。**

​**一般约定，函子的标志就是容器具有`map`方法。该方法将容器里面的每一个值，映射到另一个容器。**

​函子就是一个个的处理方法， 函子之间进行组合、排列、 包含， 对函子使用可以引发容器内的值变形，得到我们想要的结果。函数式编程就变成了运用不同的函子解决实际问题。

## pointfree 编程风格

​我们完全可以把数据处理的过程，定义成一种与参数无关的合成运算。不需要用到代表数据的那个参数，只要把一些简单的运算步骤合成在一起即可。

### 例子

我们有一个处理问题的函数

```
fn： a -> b
```

如果 fn 逻辑比较复杂，我们会倾向于把它拆开

```
f1 :: a -> m
f2 :: m -> n
f3 :: n -> b
```

这样就多了两个中间值 m 、 n ， 但是我们想要的只是最终的 b

```
fn = R.pipe(f1, f2, f3);
```

这样我们就可以只关注过程， 而不用担心 m、n 对我们的影响， 甚至a 和 b 是什么我们也不需要关注，因为这只是一段处理问题的逻辑。

### 特点

**这就叫做 Pointfree：不使用所要处理的值，只合成运算过程。**中文可以译作"无值"风格。

​Pointfree 就是运算过程抽象化，处理一个值，但是不提到这个值。这样做有很多好处，它能够让**代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举**。

​Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。

## [ramda](https://ramda.cn/)

### 介绍

Ramda 主要特性如下：
- Ramda 强调更加纯粹的函数式风格。数据不变性和函数无副作用是其核心设计理念。这可以帮助你使用简洁、优雅的代码来完成工作。
- Ramda 函数本身都是自动柯里化的。这可以让你在只提供部分参数的情况下，轻松地在已有函数的基础上创建新函数。
- Ramda 函数参数的排列顺序更便于柯里化。要操作的数据通常在最后面。



### 哲学

**简单的、 轻量的、 必须的** 才会被加入到 ramda  函数中
#### 深度和广度

1. 广度，包含多少种不同的 API。Ramda 对广度没有特别限制，也不用担心广度增加而导致库本身的崩溃（不可维护）。
2. 深度，一个 API 可以支持多少不同的行为。Ramda 倾向于每个 API 都不要太深。在 Lodash 中，比如 pluck 可以支持列表、对象和字符串，而 Ramda 只支持 列表。

##### api 太深问题

Ramda 认为深度过深会增加不必要的复杂性，维护变复杂。因此如果有一个功能既可以操作列表也可以操作对象，则会创建两个单独函数。如果有一个可选参数，那么也会创建两个函数。


##### 广度的

Ramda 希望库不要过于庞大，

1. 没有一个具体的方案，不因为一个函数容易实现且可能有用就包含，但也可能广泛被使用而被包含
2. 实现的性能优于实现的优雅
3. 坚持一致性，例如命名风格：by 单参，with 更一般情况（两个参数）

#### 函数式

##### **组合性：** 

ramda 的函数目标是允许用户使用小的可组合的函数。

大型的工具应该用较小的工具构建，每个工具只做一件事。系统复杂性只与问题域的内在复杂性有关，而不是库中添加的一些偶然复杂性。

##### 不变性

不改变输入值

##### 实用性

Ramda 的目标是成为一个实用的库，但并非所有的实用函数都可以放入到这个库中，不符合 Ramda 哲学的函数不能放进去。

### [API](https://ramda.cn/docs/)

柯里化函数的参数占位符。允许部分应用于任何位置的参数。

假设 `g` 代表柯里化的三元函数，`_` 代表 `R.__`，则下面几种写法是等价的：

- `g(1, 2, 3)`
- `g(_, 2, 3)(1)`
- `g(_, _, 3)(1)(2)`
- `g(_, _, 3)(1, 2)`
- `g(_, 2, _)(1, 3)`
- `g(_, 2)(1)(3)`
- `g(_, 2)(1, 3)`
- `g(_, 2)(_, 3)(1)`

#### [API主要功能](https://www.ruanyifeng.com/blog/2017/03/ramda.html)

一、比较运算
二、数学运算
三、逻辑运算
四、字符串
五、函数
六、数组
七、对象



























































