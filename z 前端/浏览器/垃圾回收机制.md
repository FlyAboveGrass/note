### 垃圾回收机制是什么？

​    垃圾回收机制（Garbage Collection，一般简称GC）是js用于清除内部不再使用的变量，释放变量所使用的内容的一种手段。

### 垃圾回收机制的策略

​    垃圾回收的执行并不是实时的，并不是变量一不使用就立即释放，而是会按照一定的事件间隔对垃圾进行回收。一方面是因为垃圾回收是一个开销比较大的行为，另一方面垃圾回收的时候JS会停止响应其他的操作。

​    值得注意的是： **只有局部变量是需要进行垃圾回收的，全局变量不会被垃圾回收机制回收。**

#### 标记清除

​    标记清除是JS中最常用的垃圾回收策略。当一个变量进入了环境时，就将这个变量标记为“进入环境”，当变量离开环境的时候，就将其标记为“离开环境”。被标记为“离开环境”的变量就会被回收掉。

#### 引用计数

​    当一个声明一个引用类型的值并且赋给一个变量，这个值的引用次数变成1。当这个值引用被赋给其他变量，引用次数 +1，当包含这个值引用的变量被销毁或者被赋了其他值没那么这个值引用的引用次数-1，当引用次数为0，则回收这个值引用占用得内存空间。

存在问题：这种方式下不能够解决**循环引用**的问题。循环引用的意思就是一个对象a中有一个变量指向了另一个变量b的内容，而对象b中又存在一个变量指向了对象a的内容，那么对象a和对象b的引用永远不为0，也就不会被回收了。

### V8引擎的垃圾回收算法

V8引擎中将内存分为**新生代和老生代**。新生代是存活时间比较短的对象，老生代是存活时间比较长的对象。

#### 新生代的垃圾回收

对新生代进行垃圾回收的时候主要通过Scavenge算法进行垃圾回收，在Scavenge的具体实现中主要采用了Cheney算法，属于一种**牺牲空间换时间**的算法。

1. Cheney算法将新生代内存一分为二为**两个semispace（半空间）**，一个使用状态的称为From空间，另一个闲置状态的称为To空间。

2. 分配对象空间的时候都分配到From空间，开始进行垃圾回收的时候，检查From空间的对象是否存活，不存活的将被清除，存活的对象将被复制到To空间，复制完成之后，From空间和To空间的角色进行互换。也就是说，To空间用来保存继续使用的对象，From空间接受新的对象。

3. 当一个对象经过了多次复制，存在时间已经较长的情况下就会被分配到老生代中，使用新的算法进行管理。

>  需要注意的是，如果To空间不足的时候，对象会直接进入老生代中

#### 老生代的垃圾回收

老生代的垃圾回收通过Mark-Sweep & Mark-Compact。

1. 浏览器会将老生代中的所有对象进行遍历，标记所有的活对象，然后将不活跃的对象进行清除。
2. Mark-Sweep在进行标记清除之后，内存空间会出现碎片化的形态，内存空间不再是连续的了。这时候Mark-Compact会将活对象向一端移动，使内存重新整合成连续且完成的内存空间（这时候也会同时更新引用这个空间的变量的地址）。

#### 增量标记

​    在前面说过，进行垃圾回收的时候，需要将应用逻辑停下来，执行完垃圾回收之后才会继续执行js逻辑。但是有的时候这个过程是比较久的，就会造成明显的卡顿。

​    为了避免这种卡顿，V8会在标记阶段，就将原来一次性完成的标记改成一小段一小段的增量标记，每次进行一个标记之后，就让js逻辑执行一段时间，让js逻辑和垃圾回收交叉执行，直到标记完成

> 更详细的内容请看这个http://newhtml.net/v8-garbage-collection/



### 内存泄漏

内存泄漏： 程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但多次则会造成内存溢出。

内存溢出：是指程序在申请内存时，没有足够的内存空间供其使用。

#### 什么时候会内存泄漏

+ 意外的全局变量
+ 没有清除的定时器和计时器
+ 闭包（以前在老版本的IE浏览器中,闭包确实会导致内存泄漏,这是浏览器的bug.其实闭包并不会引起内存泄漏的。）
+ 没有清除的 Dom 元素引用
  
  ```
  // 常见错误使用：如果调用这个函数的window对象，这个bar就会变成全局变量
  function foo() { 
      this.bar = "this is a hidden global variable";
  } 
  ```

#### 垃圾回收性能优化

- 对象复用。复用的对象可以少开辟一些内存空间。
- 避免在循环里面定义变量或者对象。
- 不用的变量可以手动置空。