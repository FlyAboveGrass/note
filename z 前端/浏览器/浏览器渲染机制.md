### 浏览器的工作流程

1. 将html转化成DOM树
2. 将css转换成css树
3. 生成渲染树
4. 形成布局

### 将html转化成DOM树

​    html在传过来的时候，都是一个字符串。html不能够被一般的自顶向下或者自底向上的解析器所解析，浏览器有自己的解析器parser去解析它。解析html成dom树的过程可以分为两个阶段： 标记化、树构建。

#### 1、标记化的算法

```
<html>  
<body> 
    hello world! 
</body> 
</html>  
```

浏览器根据W3C的标准规定将html中的字符串转化成各种token（如`<div>`）。标记化算法的状态机中有三种状态，根据这三种状态的变化而识别出来所有的标记。

- 标记打开状态
- 数据状态
- 标记名称状态 

浏览器解析的步骤有以下三种情况。

1. 初始状态为“数据状态”。遇到“<” 进入“标记打开状态“ ， 在里面遇到a-z的字母时会进入”标记名称状态“，接着遇到”>“会发送这段时间内识别到的标记，数据重置成 ”数据状态“。

2. 在数据状态下，接收到的”hello world！“内容，会直接发送字符标记。

3. 在”</body>“处时，遇到”<“变成标记打开状态。当接受”/“时，会创建一个闭合标签token并进入标记名称状态，直到接受”>“.

#### 2、构建树

树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是“initial mode”。接收 HTML 标记后转为“before html”模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。

状态改为“before head”。此时我们接收“body”标记。由于容错性，就算我们的没head标签，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。

进入了“in head”模式，然后转入“after head”模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为“in body”。

接收由“hi”字符串生成的一系列字符标记。接收第一个字符时会创建并插入文本节点，而其他字符也将附加到该节点。当然还有其他节点，比如属性节点、换行节点。我们实际场景还有外部资源以及其他各种各样的复杂标签嵌套和内容结构，不过原理都类似。对于中间这个过程，遇到外部资源如何处理，顺序是怎样的，后面再讲。

接收 body 结束标记会触发“after body”模式。现在我们将接收 HTML 结束标记，然后进入“after after body”模式。接收到文件结束标记后，解析过程就此结束，dom树已经建立完毕（不是加载完毕，在DOMContentLoaded之前，document.readyState = ‘interactive ’）。

### 将css转换成css树

一个元素的样式有两种获得的途径，一种是直接为此元素设置的样式，另一种是由父元素继承而来的样式。也正因为元素的样式来源不能确定，所以样式要提前加载解析好构建成css树才可以被浏览器使用，没有生成完的css树是不准确的，所以css的加载会阻塞页面就是这个道理（css阻塞dom渲染，但是不会阻塞dom的解析）。尽早将css加载到浏览器有利于首屏的迅速加载。    

并且，当js对于css样式进行修改的时候，浏览器会暂停脚本运行和dom构建，以避免一边构建一边修改产生的不可控性。**js脚本运行会阻塞dom的解析，但是不会停止dom的加载。综上，可以得知，页面性能优化的一大途径便是先加载css，再加载html，最后再加载js。**

### 生成渲染树

在这里，浏览器开始渲染出dom和css形成的渲染树。一开始，浏览器会从dom的根节点开始遍历每每一个节点，然后把需要显示的内容渲染出来。然后对于每个可见的节点，浏览器为他们匹配到对应的css规则，然后就生成了渲染树。

不可见的节点有两种：

- 不可见的标签。
- 脚本标记等css隐藏内容。 display：none；

### 形成布局

节点再渲染树的时候，已经有了初步的内容，但是具体的位置还没有确定。到了布局阶段，会触发浏览器的重排 .    

HTML是流式布局,处于流后面的元素一般不会影响到流前面元素的位置.布局从上到下,从左到右的方式对元素的位置进行排列,以浏览器的左上角为原点,依次向下展开.    

每一个元素都有自己独立的呈现器,从文档的最外层开始,外层呈现器调用内容的呈现器,不断的向下进行递归调用,需要换行的时候,则通知父元素创建额外的呈现器,在下一行继续进行布局.最后确定所有元素的绝对位置.

### 浏览器性能优化

1. 先加载css，然后是html，最后加载js。
2. 减少重排。
   - 不要一条条更改样式，用class批量修改。
   - 使用visiable而不是display：none；
   - 有动画的dom使用绝对定位，图片里文档流。
3. 降低选择器的复杂度。使用低层级的元素设置样式、用class代替伪类和深层次的样式
4. 尽量避免运行时改变元素的集合属性（读写宽高），这会触发重排。如果必须使用，优先使用flexbox，它会减少布局的开销。