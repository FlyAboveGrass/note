## 什么是 Monorepo 



先了解一下目前常见的三种包管理方式

- multirepo。即每个模块/包单独作为一个 git 仓库进行管理，分别发到 git 仓库和 npm 上，仓库间的调用共享则是通过NPM或者其他代码引用的方式进行。
- Single-repo Monolith：同样也只有一个仓库，而它并不会独立的分割每个代码工程，而是让他们成为一体来进行开发管理，模块的拆分取决于代码工程的设计。
- Monorepo



**Monorepo** 是管理项目代码的另一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)，而代码工程之间可以通过相应的工具简单的进行代码共享。形成的项目结构会类似于

```
├── packages
|   ├── package1
|   |   ├── package.json
|   ├── package1
|   |   ├── package.json
├── package.json
```



## Monorepo 的优缺点及适用场景

### 

### 优点

- 统一管理：由于只有一个仓库，所有的配置都可以统一进行管理，而无需为不同项目重复构建环境，包括通用的代码规范检测，相同的测试框架，以及统一的CI/CD构建流程等。
- 原子提交：这一点也是建立在统一管理的基础之上，使用原子提交轻松重构全局特性，而无需为每个repo执行拉取请求找出构建更改的顺序。这样可以简单的保持所有项目的全局特性是统一的，并且交由专人进行维护升级，而各个代码工程的开发者无需过度关注。
- 简单依赖：多个代码工程的相同依赖可以提升至根目录进行管理，大大减少重复安装所带来的空间浪费。同时，代码工程之间也可以在保持隔离的同时相互引用，而无需在构建时依次构建相关依赖包并重新发布。
- 文化开放：由于使用相同的代码库，所有开发者都能够浏览以及提交代码，在一定程度上也会激励团队成员共建可复用的组件及工具方法。





### 缺点

- 权限管理。不能给每个package 单独配置项目权限。
- 项目体积膨胀很快。由于是多个包放在一起，容易导致项目的体积迅速膨胀。





### 适用场景

- 代码规模相对来说不会太大，包括代码数据量和packages量。
- 代码并不涉及机密性核心技术，无需做较强的权限管理。
- 代码的技术选择相对统一，可复用性强。
- 公司文化鼓励协同合作，共建代码。







## 用 lerna 实现 Monorepo





1. 项目初始化： `lerna init`

    - `lerna.json` 下修改你的配置，推荐：

    ```
    {
      "packages": [ // 指定你的包的位置
        "packages/*"
      ],
      "version": "independent", // 不同的包使用独立的版本号
      "command": {
        "publish": { // 发布配置
          "ignoreChanges": ["ignored-file", "*.md"],
          "message": "chore: publish",
          "registry": "你的私有 npm 地址"
        },
        "bootstrap": {
          "npmClientArgs": ["--no-package-lock"]
        }
      }
    }
    ```

2. 创建你的包 `lerna create packagename`

3. **将子项目的依赖包提升到最顶层**，子包共享 node_modules。 `lerna bootstrap`

4. 子包编码之后发布。 `lerna publish`

















